//=========================================================
// src/Smart_Switch_Mini_main.c: generated by Hardware Configurator
//
// This file will be updated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8BB1_Register_Enums.h>                  // SFR declarations
#include "InitDevice.h"
#include "../WDT_Driver/inc/wdt_0.h"
#include "pins_typedef.h"

// $[Generated Includes]
// [Generated Includes]$

//WATCHDOG DEFINES
#define LFOCLK_HZ 10000UL          // LFOSC default frequency, in Hz
#define WDT_TICKS (LFOCLK_HZ*13)   // ~this gives approximately 26,2 seconds of timeout

// Default system clock for UB3 is 24.5 MHz HFOSC divided by 8
#define SYSTEM_CLOCK_FREQUENCY  (24500000 / 4)

// WDT delay cycles as defined by Erratum WDT_E102 is 2 clock cycles
#define WDT_DELAY_CYCLES        2

//DEFINES  OF THE ZEROCROSS TIME
#define MS_CONVERTER(tempo_ms)    ((tempo_ms/1000)/0.000099918)
#define RELAY_ON_TIME           MS_CONVERTER(2.6)
#define RELAY_OFF_TIME           MS_CONVERTER(4.2)

//GENERAL DEFINES
#define ERROR -1

volatile unsigned short cnt_zerocross = 0;
volatile unsigned short cnt_SW = 0;
volatile unsigned short zerocross_timeout = 0;
volatile unsigned short input_timeout = 0;
volatile unsigned short button_toggle_time = 0;

unsigned char SW_verify(void);
void relay_control(unsigned char state);
unsigned short input_verify(void);

//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
// This function is called immediately after reset, before the initialization
// code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
// useful place to disable the watchdog timer, which is enable by default
// and may trigger before main() in some instances.
//-----------------------------------------------------------------------------
void SiLabs_Startup (void)
{
  // $[SiLabs Startup]
  // [SiLabs Startup]$
}

//-----------------------------------------------------------------------------
// main() Routine
// ----------------------------------------------------------------------------
int main (void)
{
  unsigned char WdtReset = 0;
  unsigned char input = 0;

  // Call hardware initialization routine
  enter_DefaultMode_from_RESET();
  
  //***********************************************************
  // REMOVE THIS BLOCK FOR PRODUCTION DEPLOY
  //***********************************************************
  // Check to see if the WDT was the last reset cause
  if (RSTSRC & RSTSRC_WDTRSF__SET)
    {
       WdtReset = true;
       while(1){
           RELAY_OUT = 1;
     }
   }
//***********************************************************

  // Feed WDT timer before disabling (Erratum WDT_E102)
      WDT0_feed();
      // Add 2 LFO cycle delay before disabling WDT (Erratum WDT_E102)
      WDT0_delay(SYSTEM_CLOCK_FREQUENCY, LFOCLK_HZ, WDT_DELAY_CYCLES);
       // Disable WDT before changing interval
      WDT0_stop();
      // Delay 2 LFO cycles to ensure WDT is completely disabled
      WDT0_delay(SYSTEM_CLOCK_FREQUENCY, LFOCLK_HZ, WDT_DELAY_CYCLES);
      // Change WDT interval
      WDT0_init(WDT0_ticksToInterval(WDT_TICKS), WDT0_LFOSC, WDT0_IDLE_SUSPEND);
      // Start WDT
      WDT0_start();


  while (1) 
  {
    // $[Generated Run-time code]
    // [Generated Run-time code]$
      // Reset the Watchdog Timer
      WDT0_feed();
      // Delay between WDT feeds to work around Erratum WDT_E101
      WDT0_delay(SYSTEM_CLOCK_FREQUENCY, LFOCLK_HZ, WDT_DELAY_CYCLES);

      if(SW_verify()){
          BUTTON_OUT = 0;
      }else{
          BUTTON_OUT = 1;
      }

      if(input_verify()){
          BUTTON_OUT = 0;
          button_toggle_time = 2500;
          while(button_toggle_time){};
          BUTTON_OUT = 1;
      }

      if(RELAY_IN){
          relay_control(1);
      }else{
          relay_control(0);
      }
  }                             
}


//-----------------------------------------------------------------------------
// SW_verify() Routine
// ----------------------------------------------------------------------------
// This function verify if button is pressed and provide noise filter or debouce filter,
// so fake triggers can be avoided
//
//  Return:
// -If the current button is press -> 1
// -If the current button is not press or is a fake trigger -> 0
//-----------------------------------------------------------------------------
unsigned char SW_verify(void){

    if(!BUTTON_IN){
      cnt_SW = 100;
      while(cnt_SW && !BUTTON_IN){};
      if(!cnt_SW)return 1;
    }

    return 0;
}


//-----------------------------------------------------------------------------
// relay_control() Routine
// ----------------------------------------------------------------------------
// This function control the relay pin and toggle the output as close as possible to the
// zero angle of sinusoid, this is possible thanks to reading the zerocross
//
//  Parameters:
//  -state -> state of the output (can be 0 or 1)
//-----------------------------------------------------------------------------

void relay_control(unsigned char state){

  zerocross_timeout = 2000;

  if(!ZEROCROSS){

    while(!ZEROCROSS && zerocross_timeout){};

  }else{

    while(ZEROCROSS && zerocross_timeout){};

  }

  zerocross_timeout = 2000;

  if(!state){
      cnt_zerocross = RELAY_OFF_TIME;
      while(cnt_zerocross && zerocross_timeout){};
      RELAY_OUT = 0;

  }else{
      cnt_zerocross = RELAY_ON_TIME ;
      while(cnt_zerocross && zerocross_timeout){};
      RELAY_OUT = 1;
  }
}


//-----------------------------------------------------------------------------
// input_verify() Routine
// ----------------------------------------------------------------------------
// This function control verify input of control signal
//
//  Return:
// -Toggle output
//-----------------------------------------------------------------------------

unsigned short input_verify(void){
  static unsigned char flag0 = 0;
  unsigned char  flag1 = 0;
  unsigned char counter = 0;

  input_timeout = 1500;

  while(input_timeout){

      if(!IN && !flag1){
          counter++;
          flag1 = 1;
      }else if(IN){
          flag1 = 0;
      }
  }

  if(counter >= 4 && !flag0) {
      flag0 = 1;
      return 1;
  }else if(counter == 0 && flag0){
      flag0 = 0;
      return 1;
  }
  return 0;
}
